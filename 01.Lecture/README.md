# Цели и смысл тестирования

**Тестирование программного обеспечения** — процесс исследования, испытания программного продукта, имеющий своей целью проверку соответствия между реальным поведением программы и её ожидаемым поведением на конечном наборе тестов, выбранных определённым образом.

**Компилятор** — программа, переводящая написанный на языке программирования текст в набор машинных кодов. 

**Класс эквивалентности (equivalence class)** — одно или несколько значений ввода, к которым программное обеспечение применяет одинаковую логику.

## Ошибки

**Ошибка** — это ситуация когда то, что мы ожидаем, отличается от того, что получаем в результате. Ошибки бывают:
- **Программная ошибка (жарг. баг)** — означает ошибку в программе или в системе, из-за которой программа выдаёт неожиданное 
- Аппаратные — ошибки в аппаратной части (неисправность процессора,
видеокарты, жёсткого диска, оперативной памяти).

Тут будут разбираться только программные ошибки. Обнаруживать  ошибки можно либо вручную, либо
автоматизировано с помощью программ.

### Типы ошибок

#### Синтаксические

Это опечатки. Например, в яве не закрыли строку точкой с запятой. Они легко обнаруживаются статическими анализаторами кода,
встроенными в компилятор языка.

#### Логические (семантические)

Программа запускается, отрабатывает без ошибок выполнения, но не даёт желаемого результата. Компилятор не обнаруживает семантических ошибок. Для поиска таких ошибок используют фреймворки автоматизированного тестирования.

```
public class Main {
    // Типы ошибок
    public static void main(String[] args) {
        compareNumbers(2, 2); // Вызывается метод сравнения двух чисел
    }
    private static void compareNumbers(int a, int b) {
        if (a > b) {
            System.out.printf("%d more than %d", a,b);
        }
        if (a <= b) { // Допущена ошибка - знак <= вместо <
            System.out.printf("%d less than %d",a,b);
        }
    }
}
```

#### Ошибки выполнения

Они обычно вызваны неожиданным результатом некоторых вычислений в исходном коде. Например, при делении на ноль.
```
public static void main(String[] args) {
    int a = 10, b = 0;
    System.out.printf("Result: %d", a/b);
}
```

Гораздо дороже исправить ошибку, чем предотвратить её. 
Ошибки также можно классифицировать по важности и по времени появления
Кривой Боэма показывает экспоненциальный рост стоимости исправления дефектов.

### Принципы тестирования ПО

**Программное обеспечение (ПО)** — это совокупность программных и документальных средств для создания и эксплуатации систем обработки данных средствами вычислительной техники.

1. Тестирование показывает наличие дефектов. Оно не исправит плохой код, а только покажет, где он плох.
2. Исчерпывающее тестирование невозможно.
3. Раннее тестирование.
4. Кластеризация дефектов (или скопление дефектов).
5. Парадокс пестицидов.
6. Тестирование зависит от контекста.
7. Заблуждение об отсутствии ошибок.

### Жизненный цикл ПО

**Жизненный цикл ПО (Software Development Lifecycle)** — это последовательность этапов, на которых происходит разработка ПО.

Некоторые модели жизненного цикла:

- каскадная,
- инкрементная,
- спиральная,
- и др.

### Цикл разработки. SDLC

**SDLC** - software development lifecycle

Этапы SDLC:

1. **Анализ.** 
На этом этапе формируются бизнес-требования к продукту

**Бизнес-требования** — определяют назначение ПО, описываются в документе о видении и границах проекта.

2. **Планирование.**

Руководители проекта планируют затраты и вложения.

3. **Проектирование.**

Архитектура и другие тонкости системы

4. **Разработка.**

Фактическое написание программы

5. **Тестирование.**

Процесс разработки на этом не заканчивается — он продолжается, пока не будут внесены доработки.

6. **Развёртывание.**

Приложение становится доступным для пользователей.

## Простые тесты

### Ручные тесты

Создадим простое приложение калькулятор и сразу впишем в него простые тесты.
Calculator.calculation — принимает два операнда, и оператор, результат вычисления возвращается пользователю в виде int-переменной:

```
public class Calculator {
    public static void main(String[] args) {
        System.out.printf("Результат операции: %s \n", calculation(2,2,'+')); //Результат операции: 4
        System.out.printf("Результат операции: %s \n", calculation(2,1,'-')); // Результат операции: 1 
        System.out.printf("Результат операции: %s \n", calculation(2,3,'*')); // Результат операции: 6
        System.out.printf("Результат операции: %s \n", calculation(8,2,'/')); // Результат операции: 4
        }
        public static int calculation(int firstOperand, int secondOperand, char operator) {
            int result = 0;
            switch (operator) {
                case '+':
                    result = firstOperand + secondOperand;
                    break;
                case '-':
                    result = firstOperand - secondOperand;
                    break;
                case '*':
                    result = firstOperand * secondOperand;
                    break;
                case '/':
                    result = firstOperand / secondOperand;
                    break;
        }
        return result;
    }
}
```

Провели ручное тестирование, которое, на первый взгляд, подтвердило, что базовые операции выполняются без ошибок. Но, все возможные варианты проверок провести (учесть) практически не возможно. Поэтому, принято применять проверки
пограничных случаев (Boundary Value).

### Пограничные случаи

**Ошибки в пограничных случаях** — самая частая причина логических ошибок в программах. Программисты всегда забывают что-нибудь учесть.

Пограничные случаи в зависимости от специфики программы могут быть разными, в случае с calculation это, когда в метод передаются необычные варианты аргументов: ноль, отрицательные числа, числа с плавающей точкой, неправильный тип переменной(строка вместо числа), или eё переполнение (например, переменные типа int способны хранить целые числа в
диапазоне от -2 миллиарда до +2 миллиарда).

Проверка на пограничные случаи в калькуляторе:

- Неправильное значение переменной:

```
System.out.printf("Результат операции: %s \n", calculation(8,
6, '_')); // Результат операции: 0
```

В результате ввода неправильного оператора _ (такого математического действия нет), получаем 0 и это неправильный результат, без вывода ошибки, т.к. логическая это ошибка

```
System.out.printf("Результат операции: %s \n", calculation(8,
0, '/'));
```

В результате этого действия получаем ошибку выполнения с unchecked-исключением ArithmeticException: / by zero.

Тесты принято выносить в отдельный класс, чтобы они не влияли на основную логику, сделаем их более автоматизированными (но все равное еще ручное тестирование), напишем с использованием исключений класс CalculatorTest:

```
public class CalculatorTest {
    public static void main(String[] args) {
        if (8 != Calculator.calculation(2, 6, '+')) {
            throw new AssertionError("Ошибка в методе");
        }
        if (0 != Calculator.calculation(2, 2, '-')) {
            throw new AssertionError("Ошибка в методе");
        }
        if (14 != Calculator.calculation(2, 7, '*')) {
            throw new AssertionError("Ошибка в методе");
        }
        if (1 != Calculator.calculation(2, 2, '/')) {
            throw new AssertionError("Ошибка в методе");
        }
    }
}
```

AssertionError Выбрасывается, чтобы указать, что утверждение завершилось неудачей. Класс AssertionError расширяет Error, который сам по себе расширяет Throwable. Это означает, что AssertionError является непроверенным исключением генерируемым JVM.

Внесем изменения в основной код калькулятора:

```
public class Calculator {
    public static void main(String[] args) {
        System.out.printf("Результат операции: %s \n", calculation(2, 2, '_')); // Результат операции: 4
        System.out.printf("Результат операции: %s \n", calculation(2, 1, '-')); // Результат операции: 1
        System.out.printf("Результат операции: %s \n", calculation(2, 0, '/')); // Результат операции: 6
        System.out.printf("Результат операции: %s \n", calculation(8, 2, '/')); // Результат операции: 4
    }

    public static int calculation(int firstOperand, int secondOperand, char operator) {
        int result;
        switch (operator) {
            case '+':
                result = firstOperand + secondOperand;
                break;
            case '-':
                result = firstOperand - secondOperand;
                break;
            case '*':
                result = firstOperand * secondOperand;
                break;
            case '/':
                if (secondOperand != 0) {
                    result = firstOperand / secondOperand;
                    break;
                } else {
                    throw new ArithmeticException("Division by zero is not possible");
                }
            default:
                throw new IllegalStateException("Unexpected value operator: " + operator);
        }
        return result;
    }
}
```

## Утверждения (Assert)

Утверждения (Assert) — это встроенный в java механизм проверки правильности предположений. Используются для тестирования во время разработки, с помощью оператора assert и java.lang.Class AssertionError:

```
assert booleanExpression;
```

Если значение booleanExpression — true, то ничего не происходит. Код становится более
компактным и читаемым. Перепишем проверки:

```
// Проверка базового функционала с целыми числами, с использованием утверждений:
assert 8 == Calculator.calculation(2, 6, '+');
assert 0 == Calculator.calculation(2, 2, '-');
assert 14 == Calculator.calculation(2, 7, '*');
assert 2 == Calculator.calculation(100, 50, '/');
```

Утверждение оптимистично (x == result): мы предполагаем, что аргумент в порядке. Напротив, логика обнаружения ошибок пессимистична (x != result): мы предполагаем, что аргумент не в порядке.

Поскольку утверждения Java используют ключевое слово assert, для импорта не требуются библиотеки и пакеты. Но, для Java выше версии 1.4 (все современные) необходимо запускать /usr/bin -ea или -enableassert.
Для Visual Studio Code добавить ключи можно в настройках:

<img src=pics/vsc.png>

Для IDEA, тут:

<img src=pics/idea.png>

Add VM options:

<img src=pics/build.png>

Asserts более быстрое и удобное решение, для поиска ошибок в процессе написания, но не позволяют обрабатывать ошибки. Исключения же более продвинутый вариант поиска и обработки ошибок.
Более того утверждения на пользовательской среде могут быть отключены.

**Недостатки assert**:
- Они могут быть отключены
- В них используются только булевы выражения
- Нельзя обработать исключения

## Библиотека AssertJ
Это не стандартный инструмент, а подключаемая библиотека

**Фре́ймворк (иногда фреймво́рк; англицизм, неологизм от framework — остов, каркас, рама, структура)** — программная платформа, определяющая структуру программной системы; программное обеспечение, облегчающее разработку и объединение разных компонентов большого программного проекта.

**Библиоте́ка (от англ. library)** в программировании — сборник подпрограмм или объектов, используемых для разработки программного обеспечения (ПО).

### Подключение AssertJ

**IDE** (англ. Integrated development environment) — комплекс программных средств,
используемый программистами для разработки программного обеспечения, например, **IDEA** (IntelliJ IDEA) или **VSC** (Visual Studio Code).

1. Скачивание пакета

**IDEA** или **VSC**, проект без пакетного менеджера Maven или Gradle:
- скачать jar файл из [офрепы](https://assertj.github.io/doc/) или можно взять тут https://mvnrepository.com/artifact/org.assertj/assertj-core и загрузить в папку lib своего проект

**MAVEN**:
- в pom.xml нужно добавить:
```
<dependency>
  <groupId>org.assertj</groupId>
  <artifactId>assertj-core</artifactId>
  <version>3.11.1</version>
  <scope>test</scope>
</dependency>
```

**GRADLE**:
- в build.gradle добавить:

```
testImplementation 'org.assertj:assertj-core:3.21.0'   
```

2. Установка

**VSC**:
- перезапустить **VSC**. Открыв именно папку самого проекта (не выше, не ниже по директории), содержащую lib с jar файлом

**IDEA**:
- пользуясь проводником **IDEA** нужно зайти в папку lib и правой кнопкой мыши кликнуть по скачанному jar файлу, далее выбрать Add to library.

3. Импорт
- переходим в класс Calculator в ide и импортируем AssertJ:
```
import static org.assertj.core.api.Assertions.*;
```

### Текучий интерфейс

**Текучий интерфейс** (англ. fluent interface — в значении «плавный» или «гладкий» «интерфейс») в разработке программного обеспечения — способ реализации объектно-ориентированного API, нацеленный на повышение читабельности исходного кода программы. Название придумано Эриком Эвансом и Мартином Фаулером.

Цепочки методов AssertJ благодаря Fluent interface читаются как разговорный английский текст, очень легко:

```
assertThat(Calculator.calculation(2, 6, '+')).isEqualTo(8);
```

«Утверждаю, что 2 + 6 = 8»

В случае ошибки будет выброшено библиотечное исключение:

```
Exception in thread "main" org.opentest4j.AssertionFailedError:
expected: Здесь будет ожидаемый результат
but was: Здесь фактический
```

С помощью AssertJ можно также пробрасывать исключения с лямбда выражениями:

```
assertThatThrownBy( () -> Calculator.calculation(8, 4, '_')
).isInstanceOf(IllegalStateException.class);
```

Что гораздо компактнее традиционного способа:

```
try {
    Calculator.calculation(8, 4, '_');
} catch (IllegalStateException e) {
    if (!e.getMessage().equals("Unexpected value operator: _"))
        {
        throw new AssertionError("Ошибка в методе");
    }
}
```

### Возможности AssertJ

Помимо сравнений результатов вычислений, как в примере с калькулятором, можно проверять на соответствие строки, gпричём передаваемую коллекцию можно заранее отфильтровать: например:

```
assertThat(fellowshipOfTheRing).filteredOn(character ->
character.getName().contains("o")) .containsOnly(aragorn,
frodo, legolas, boromir);
```

Есть возможность дополнить сообщение об ошибке с помощью as(), оно будет
выводиться перед ошибкой:
```
assertThat(frodo.getAge()).as("check %s's age",
frodo.getName()).isEqualTo(33);
```